<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Astro Defender — Single File HTML5 Game</title>
<style>
  :root{
    --bg:#0b1020; --panel:#0f1724; --accent:#4ee1a1; --danger:#ff6b6b;
    --muted:#9aa7bf; --glass: rgba(255,255,255,0.04);
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(180deg,var(--bg),#07101a);color:#e6eef8}
  #game-wrap{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;padding:18px;box-sizing:border-box}
  header{width:100%;max-width:1100px;display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
  h1{font-size:20px;margin:0;color:var(--accent);letter-spacing:0.6px}
  .panel{background:linear-gradient(180deg,var(--panel),#0b1220);border-radius:12px;padding:10px;box-shadow:0 6px 20px rgba(2,6,23,0.6);display:flex;gap:10px;align-items:center}
  .info{display:flex;gap:12px;align-items:center;color:var(--muted);font-size:13px}
  .btn{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;color:var(--muted);cursor:pointer;font-weight:600}
  .btn.primary{background:linear-gradient(90deg,var(--accent),#2bd6a6);color:#04221a;border:none}
  canvas{background:linear-gradient(180deg,#07101a,#04101a);border-radius:12px;display:block;max-width:100%;height:auto;box-shadow:0 12px 40px rgba(2,6,23,0.7)}
  footer{margin-top:12px;color:var(--muted);font-size:13px}
  /* HUD overlay */
  #hud{position:absolute;top:18px;left:18px;color:#dff7ee;font-weight:700;text-shadow:0 1px 0 rgba(0,0,0,0.6)}
  #controls{position:absolute;right:18px;bottom:18px;color:var(--muted);font-size:13px}
  /* Mobile touch controls */
  .touch-controls{display:none;position:fixed;left:0;right:0;bottom:12px;pointer-events:none;justify-content:center;gap:12px}
  .touch-controls .pad{pointer-events:auto;background:rgba(255,255,255,0.04);padding:10px;border-radius:12px;display:flex;gap:8px}
  .touch-controls button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:10px;border-radius:8px;font-weight:700}
  @media (max-width:720px){ .touch-controls{display:flex} header{flex-direction:column;gap:8px} }
  /* small helper */
  .muted{color:var(--muted);font-weight:600}
  .big{font-size:18px;color:#fff}
</style>
</head>
<body>
<div id="game-wrap">
  <header>
    <div style="display:flex;gap:12px;align-items:center">
      <div class="panel">
        <h1>Astro Defender</h1>
        <div style="width:1px;height:28px;background:rgba(255,255,255,0.03);margin:0 10px"></div>
        <div class="info">
          <div>Mode: <span id="mode" class="muted">Arcade</span></div>
          <div>Level: <span id="level" class="muted">1</span></div>
        </div>
      </div>
    </div>

    <div style="display:flex;gap:8px;align-items:center">
      <div class="panel" style="padding:6px 10px">
        <div class="info">
          <div>Score: <span id="score" class="big">0</span></div>
          <div style="width:1px;height:28px;background:rgba(255,255,255,0.03);margin:0 10px"></div>
          <div>Lives: <span id="lives" class="big">3</span></div>
        </div>
      </div>
      <button id="btnRestart" class="btn primary">Restart</button>
      <button id="btnPause" class="btn">Pause</button>
    </div>
  </header>

  <main style="position:relative;width:100%;max-width:1100px">
    <canvas id="game" width="900" height="600" aria-label="Astro Defender game canvas"></canvas>
    <div id="hud" aria-hidden="true">Use WASD / Arrow keys • Space to shoot</div>
    <div id="controls" aria-hidden="true">Highscore: <span id="highscore" class="muted">0</span></div>
  </main>

  <div class="touch-controls" aria-hidden="true">
    <div class="pad">
      <button id="leftBtn">◀</button>
      <button id="upBtn">▲</button>
      <button id="downBtn">▼</button>
      <button id="rightBtn">▶</button>
    </div>
    <div class="pad">
      <button id="shootBtn" class="primary">FIRE</button>
    </div>
  </div>

  <footer>
    <div class="muted">Built with Canvas & vanilla JS • Local highscore saved</div>
  </footer>
</div>

<script>
/* =========================
   Astro Defender — single file
   - Top-down shooter
   - Player ship, enemies, bullets, powerups
   - Levels, scoring, pause, mobile touch
   ========================= */

/* ---------- Utilities ---------- */
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const rand = (a,b) => Math.random()*(b-a)+a;
const now = () => performance.now();

/* ---------- Canvas setup ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });
let W = canvas.width, H = canvas.height;

/* ---------- Game state ---------- */
let state = {
  running: true,
  paused: false,
  lastTime: now(),
  dt: 0,
  score: 0,
  level: 1,
  lives: 3,
  highscore: 0,
  spawnTimer: 0,
  spawnInterval: 1200,
  enemies: [],
  bullets: [],
  enemyBullets: [],
  particles: [],
  powerups: [],
  player: null,
  keys: {},
  touch: {left:false,right:false,up:false,down:false,shoot:false},
  difficulty: 1
};

/* ---------- Save/load highscore ---------- */
const HS_KEY = 'astro_defender_highscore_v1';
function loadHighscore(){
  try{ const v = localStorage.getItem(HS_KEY); state.highscore = v?parseInt(v,10):0; }
  catch(e){ state.highscore = 0; }
  document.getElementById('highscore').textContent = state.highscore;
}
function saveHighscore(){
  try{ localStorage.setItem(HS_KEY, String(state.highscore)); }
  catch(e){}
}

/* ---------- Player ---------- */
class Player {
  constructor(){
    this.x = W/2; this.y = H - 80;
    this.r = 16; this.speed = 320; this.cool = 0; this.coolMax = 220;
    this.color = '#4ee1a1'; this.invuln = 0;
  }
  update(dt){
    const k = state.keys;
    let vx = 0, vy = 0;
    if(k.ArrowLeft || k.a || state.touch.left) vx = -1;
    if(k.ArrowRight || k.d || state.touch.right) vx = 1;
    if(k.ArrowUp || k.w || state.touch.up) vy = -1;
    if(k.ArrowDown || k.s || state.touch.down) vy = 1;
    const len = Math.hypot(vx,vy) || 1;
    this.x += (vx/len) * this.speed * dt;
    this.y += (vy/len) * this.speed * dt;
    this.x = clamp(this.x, this.r+8, W - this.r - 8);
    this.y = clamp(this.y, this.r+8, H - this.r - 120);

    // shooting
    this.cool -= dt*1000;
    if((k.Space || k[' '] || state.touch.shoot) && this.cool <= 0){
      this.shoot();
      this.cool = this.coolMax;
    }
    if(this.invuln > 0) this.invuln -= dt*1000;
  }
  shoot(){
    const b = new Bullet(this.x, this.y - this.r - 6, 0, -520, '#e6f9ff', 'player');
    b.r = 5; b.damage = 1;
    state.bullets.push(b);
    sfx('shoot');
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x, this.y);
    // ship body
    ctx.fillStyle = this.invuln>0 ? 'rgba(78,225,161,0.6)' : this.color;
    ctx.beginPath();
    ctx.moveTo(0,-18);
    ctx.lineTo(12,12);
    ctx.lineTo(0,6);
    ctx.lineTo(-12,12);
    ctx.closePath();
    ctx.fill();
    // engine glow
    ctx.fillStyle = 'rgba(255,180,80,0.12)';
    ctx.beginPath();
    ctx.ellipse(0,14,10,6,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

/* ---------- Bullet ---------- */
class Bullet {
  constructor(x,y,vx,vy,color,owner='enemy'){
    this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.color=color;this.owner=owner;this.r=6;this.damage=1;
  }
  update(dt){
    this.x += this.vx*dt; this.y += this.vy*dt;
  }
  draw(ctx){
    ctx.fillStyle = this.color;
    ctx.beginPath(); ctx.ellipse(this.x,this.y,this.r,this.r,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath(); ctx.ellipse(this.x-1,this.y-1,this.r*0.5,this.r*0.5,0,0,Math.PI*2); ctx.fill();
  }
}

/* ---------- Enemy ---------- */
class Enemy {
  constructor(x,y,type=0){
    this.x=x;this.y=y;this.type=type;this.r=18;this.hp= type===1?3:1;
    this.color = type===1? '#ffb86b' : '#ff6b6b';
    this.speed = type===1? 40 : 80;
    this.shootTimer = rand(800,2000);
  }
  update(dt){
    this.y += this.speed*dt;
    this.shootTimer -= dt*1000;
    if(this.shootTimer <= 0){
      this.shootTimer = rand(900,2200);
      this.fire();
    }
  }
  fire(){
    const angle = Math.atan2(state.player.y - this.y, state.player.x - this.x);
    const speed = 180;
    const vx = Math.cos(angle)*speed;
    const vy = Math.sin(angle)*speed;
    const b = new Bullet(this.x, this.y+this.r+6, vx, vy, '#ffd6d6', 'enemy');
    b.r = 6; b.damage = 1;
    state.enemyBullets.push(b);
    sfx('enemyShoot');
  }
  draw(ctx){
    ctx.save(); ctx.translate(this.x,this.y);
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(0,-this.r);
    ctx.lineTo(this.r,0);
    ctx.lineTo(0,this.r);
    ctx.lineTo(-this.r,0);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.beginPath(); ctx.ellipse(-4,-4,6,4,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

/* ---------- Particle (for effects) ---------- */
class Particle {
  constructor(x,y,vx,vy,color,life=600){
    this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.color=color;this.life=life;this.age=0;this.r=2;
  }
  update(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; this.age+=dt*1000; }
  draw(ctx){
    const t = 1 - (this.age/this.life);
    if(t<=0) return;
    ctx.fillStyle = hexAlpha(this.color, t);
    ctx.beginPath(); ctx.ellipse(this.x,this.y,this.r*t*2,this.r*t*2,0,0,Math.PI*2); ctx.fill();
  }
}

/* ---------- Powerup ---------- */
class Powerup {
  constructor(x,y,kind='score'){
    this.x=x;this.y=y;this.kind=kind;this.r=10;this.vy=60;
  }
  update(dt){ this.y += this.vy*dt; }
  draw(ctx){
    ctx.save(); ctx.translate(this.x,this.y);
    ctx.fillStyle = this.kind==='life' ? '#4ee1a1' : '#ffd166';
    ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath(); ctx.arc(-3,-3,4,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

/* ---------- Helpers ---------- */
function hexAlpha(hex, a){
  // hex like #rrggbb
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${a})`;
}

/* ---------- Spawning ---------- */
function spawnEnemyWave(level){
  const count = Math.min(12, 3 + Math.floor(level * 1.5));
  for(let i=0;i<count;i++){
    const x = rand(40, W-40);
    const y = rand(-300, -40) - i*30;
    const type = Math.random() < Math.min(0.25, level*0.03) ? 1 : 0;
    state.enemies.push(new Enemy(x,y,type));
  }
}

/* ---------- Collision ---------- */
function circleCollide(a,b){
  const dx = a.x - b.x, dy = a.y - b.y;
  const r = (a.r||0) + (b.r||0);
  return dx*dx + dy*dy <= r*r;
}

/* ---------- Sound (tiny synth using WebAudio) ---------- */
const audioCtx = (typeof AudioContext !== 'undefined') ? new AudioContext() : null;
function sfx(type){
  if(!audioCtx) return;
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  if(type==='shoot'){ o.frequency.setValueAtTime(880,t); g.gain.setValueAtTime(0.06,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.12); }
  else if(type==='enemyShoot'){ o.frequency.setValueAtTime(420,t); g.gain.setValueAtTime(0.04,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.18); }
  else if(type==='explode'){ o.frequency.setValueAtTime(120,t); g.gain.setValueAtTime(0.12,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.4); o.type='square'; }
  else if(type==='power'){ o.frequency.setValueAtTime(1200,t); g.gain.setValueAtTime(0.06,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.18); }
  o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+0.5);
}

/* ---------- Game logic ---------- */
function resetGame(){
  state.score = 0; state.level = 1; state.lives = 3; state.enemies=[]; state.bullets=[]; state.enemyBullets=[]; state.particles=[]; state.powerups=[];
  state.spawnTimer = 0; state.spawnInterval = 1200; state.difficulty = 1;
  state.player = new Player();
  document.getElementById('score').textContent = state.score;
  document.getElementById('lives').textContent = state.lives;
  document.getElementById('level').textContent = state.level;
  state.paused = false;
}

function nextLevel(){
  state.level++;
  state.difficulty += 0.25;
  spawnEnemyWave(state.level);
  document.getElementById('level').textContent = state.level;
  sfx('power');
}

/* ---------- Update loop ---------- */
function update(dt){
  if(!state.running || state.paused) return;
  // player
  state.player.update(dt);

  // bullets
  for(const b of state.bullets) b.update(dt);
  for(const b of state.enemyBullets) b.update(dt);

  // enemies
  for(const e of state.enemies) e.update(dt);

  // particles & powerups
  for(const p of state.particles) p.update(dt);
  for(const pu of state.powerups) pu.update(dt);

  // collisions: player bullets -> enemies
  for(let i=state.bullets.length-1;i>=0;i--){
    const b = state.bullets[i];
    if(b.owner !== 'player') continue;
    let removed = false;
    for(let j=state.enemies.length-1;j>=0;j--){
      const e = state.enemies[j];
      if(circleCollide(b,e)){
        e.hp -= b.damage;
        spawnExplosion(b.x,b.y,'#ffd6d6');
        state.bullets.splice(i,1);
        removed = true;
        if(e.hp <= 0){
          // enemy destroyed
          spawnExplosion(e.x,e.y,'#ffb86b', 18);
          state.enemies.splice(j,1);
          state.score += (e.type===1? 150 : 50) * Math.round(state.difficulty);
          // chance for powerup
          if(Math.random() < 0.12) state.powerups.push(new Powerup(e.x,e.y,'life'));
          else if(Math.random() < 0.18) state.powerups.push(new Powerup(e.x,e.y,'score'));
          sfx('explode');
        }
        break;
      }
    }
    if(removed) continue;
    // remove offscreen
    if(b.y < -20 || b.y > H+20 || b.x < -40 || b.x > W+40) state.bullets.splice(i,1);
  }

  // enemy bullets -> player
  if(state.player.invuln <= 0){
    for(let i=state.enemyBullets.length-1;i>=0;i--){
      const b = state.enemyBullets[i];
      if(circleCollide(b, state.player)){
        state.enemyBullets.splice(i,1);
        hitPlayer();
        break;
      }
    }
  }

  // enemies -> player collision
  for(let i=state.enemies.length-1;i>=0;i--){
    const e = state.enemies[i];
    if(circleCollide(e, state.player) && state.player.invuln <= 0){
      state.enemies.splice(i,1);
      hitPlayer();
      spawnExplosion(e.x,e.y,'#ff6b6b', 20);
      break;
    }
  }

  // powerups -> player
  for(let i=state.powerups.length-1;i>=0;i--){
    const pu = state.powerups[i];
    if(circleCollide(pu, state.player)){
      if(pu.kind === 'life'){ state.lives = Math.min(5, state.lives + 1); document.getElementById('lives').textContent = state.lives; }
      else { state.score += 200; document.getElementById('score').textContent = state.score; }
      state.powerups.splice(i,1);
      sfx('power');
    } else if(pu.y > H + 40) state.powerups.splice(i,1);
  }

  // remove offscreen enemies
  for(let i=state.enemies.length-1;i>=0;i--){
    if(state.enemies[i].y > H + 60) state.enemies.splice(i,1);
  }

  // remove offscreen enemy bullets
  for(let i=state.enemyBullets.length-1;i>=0;i--){
    const b = state.enemyBullets[i];
    if(b.y > H + 60 || b.x < -60 || b.x > W + 60) state.enemyBullets.splice(i,1);
  }

  // particles cleanup
  for(let i=state.particles.length-1;i>=0;i--){
    if(state.particles[i].age > state.particles[i].life) state.particles.splice(i,1);
  }

  // spawn logic
  state.spawnTimer -= dt*1000;
  if(state.spawnTimer <= 0){
    state.spawnTimer = state.spawnInterval / Math.sqrt(state.difficulty);
    spawnEnemyWave(state.level);
  }

  // level progression: if no enemies and none incoming, next level
  if(state.enemies.length === 0 && state.enemyBullets.length === 0 && state.spawnTimer > 800){
    nextLevel();
  }

  // update HUD
  document.getElementById('score').textContent = state.score;
  // highscore update
  if(state.score > state.highscore){ state.highscore = state.score; document.getElementById('highscore').textContent = state.highscore; saveHighscore(); }
}

/* ---------- Player hit ---------- */
function hitPlayer(){
  state.lives -= 1;
  document.getElementById('lives').textContent = state.lives;
  state.player.invuln = 1400;
  spawnExplosion(state.player.x, state.player.y, '#ff6b6b', 28);
  sfx('explode');
  if(state.lives <= 0){
    gameOver();
  }
}

/* ---------- Explosion ---------- */
function spawnExplosion(x,y,color,amount=10){
  for(let i=0;i<amount;i++){
    const a = rand(0,Math.PI*2);
    const s = rand(40,260);
    const vx = Math.cos(a)*s;
    const vy = Math.sin(a)*s;
    state.particles.push(new Particle(x,y,vx,vy,color, rand(400,900)));
  }
}

/* ---------- Game over ---------- */
function gameOver(){
  state.paused = true;
  state.running = false;
  // show overlay
  setTimeout(()=> {
    const msg = `Game Over\nScore: ${state.score}\nHighscore: ${state.highscore}`;
    alert(msg);
    resetGame();
  }, 80);
}

/* ---------- Draw ---------- */
function draw(){
  // background gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#07101a'); g.addColorStop(1,'#04101a');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // starfield
  drawStars();

  // powerups
  for(const pu of state.powerups) pu.draw(ctx);

  // enemies
  for(const e of state.enemies) e.draw(ctx);

  // bullets
  for(const b of state.bullets) b.draw(ctx);
  for(const b of state.enemyBullets) b.draw(ctx);

  // player
  state.player.draw(ctx);

  // particles
  for(const p of state.particles) p.draw(ctx);

  // HUD overlay (center)
  if(state.paused){
    ctx.fillStyle = 'rgba(2,6,23,0.6)';
    ctx.fillRect(W/2 - 160, H/2 - 60, 320, 120);
    ctx.fillStyle = '#fff';
    ctx.font = '20px Inter, Arial';
    ctx.textAlign = 'center';
    ctx.fillText(state.running ? 'Paused' : 'Game Over', W/2, H/2 - 6);
    ctx.font = '14px Inter, Arial';
    ctx.fillStyle = '#bcd';
    ctx.fillText('Press Restart to play again', W/2, H/2 + 20);
  }
}

/* ---------- Starfield (simple) ---------- */
const stars = [];
for(let i=0;i<120;i++){
  stars.push({x:rand(0,W), y:rand(0,H), r:rand(0.3,1.6), s:rand(10,80)});
}
function drawStars(){
  for(const s of stars){
    s.y += s.s * 0.016 * state.difficulty;
    if(s.y > H) s.y = -2;
    ctx.fillStyle = `rgba(255,255,255,${0.06 + s.r*0.06})`;
    ctx.beginPath(); ctx.ellipse(s.x, s.y, s.r, s.r, 0, 0, Math.PI*2); ctx.fill();
  }
}

/* ---------- Input ---------- */
window.addEventListener('keydown', e => {
  state.keys[e.key] = true;
  if(e.key === 'p' || e.key === 'P') togglePause();
  if(e.key === 'r' || e.key === 'R') resetGame();
  // prevent scrolling on space
  if(e.key === ' '){ e.preventDefault(); }
});
window.addEventListener('keyup', e => { state.keys[e.key] = false; });

/* Touch controls */
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const upBtn = document.getElementById('upBtn');
const downBtn = document.getElementById('downBtn');
const shootBtn = document.getElementById('shootBtn');
function bindTouch(btn, keyName){
  btn.addEventListener('touchstart', e => { e.preventDefault(); state.touch[keyName] = true; });
  btn.addEventListener('touchend', e => { e.preventDefault(); state.touch[keyName] = false; });
  btn.addEventListener('mousedown', e => { e.preventDefault(); state.touch[keyName] = true; });
  btn.addEventListener('mouseup', e => { e.preventDefault(); state.touch[keyName] = false; });
}
bindTouch(leftBtn,'left'); bindTouch(rightBtn,'right'); bindTouch(upBtn,'up'); bindTouch(downBtn,'down'); bindTouch(shootBtn,'shoot');

/* Resize handling */
function resizeCanvas(){
  // keep internal resolution fixed but scale CSS for responsiveness
  const maxW = Math.min(window.innerWidth - 36, 1100);
  const scale = maxW / 900;
  canvas.style.width = (900 * scale) + 'px';
  canvas.style.height = (600 * scale) + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ---------- Buttons ---------- */
document.getElementById('btnRestart').addEventListener('click', () => {
  resetGame();
  state.running = true;
  state.paused = false;
});
document.getElementById('btnPause').addEventListener('click', () => togglePause());

function togglePause(){
  state.paused = !state.paused;
  document.getElementById('btnPause').textContent = state.paused ? 'Resume' : 'Pause';
}

/* ---------- Main loop ---------- */
function loop(){
  const t = now();
  let dt = (t - state.lastTime) / 1000;
  dt = Math.min(dt, 0.033); // clamp large frames
  state.lastTime = t;
  state.dt = dt;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* ---------- Init ---------- */
function init(){
  loadHighscore();
  resetGame();
  // initial wave
  spawnEnemyWave(1);
  state.player = new Player();
  state.running = true;
  state.paused = false;
  state.lastTime = now();
  loop();
}
init();

/* ---------- Extra: simple debug console commands (optional) ---------- */
window.__astro = {
  addEnemy: (n=1) => { for(let i=0;i<n;i++) state.enemies.push(new Enemy(rand(40,W-40), rand(-200,-40), Math.random()<0.2?1:0)); },
  addScore: (s=100) => { state.score += s; document.getElementById('score').textContent = state.score; },
  killAll: () => { state.enemies = []; state.enemyBullets = []; }
};
</script>
</body>
</html>
