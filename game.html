<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Astro Defender — Ultimate Single File</title>
<style>
/* ===========================
   Astro Defender — Styles
   Single-file HTML game (all CSS here)
   =========================== */
:root{
  --bg:#07101a; --panel:#0f1724; --accent:#4ee1a1; --danger:#ff6b6b;
  --muted:#9aa7bf; --glass: rgba(255,255,255,0.04);
}
html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(180deg,var(--bg),#04101a);color:#e6eef8}
#game-wrap{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;padding:18px;box-sizing:border-box}
header{width:100%;max-width:1200px;display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;gap:12px}
h1{font-size:20px;margin:0;color:var(--accent);letter-spacing:0.6px}
.panel{background:linear-gradient(180deg,var(--panel),#0b1220);border-radius:12px;padding:10px;box-shadow:0 6px 20px rgba(2,6,23,0.6);display:flex;gap:10px;align-items:center}
.info{display:flex;gap:12px;align-items:center;color:var(--muted);font-size:13px}
.btn{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:8px 12px;border-radius:8px;color:var(--muted);cursor:pointer;font-weight:600}
.btn.primary{background:linear-gradient(90deg,var(--accent),#2bd6a6);color:#04221a;border:none}
canvas{background:linear-gradient(180deg,#07101a,#04101a);border-radius:12px;display:block;max-width:100%;height:auto;box-shadow:0 12px 40px rgba(2,6,23,0.7)}
footer{margin-top:12px;color:var(--muted);font-size:13px}
#hud{position:absolute;top:18px;left:18px;color:#dff7ee;font-weight:700;text-shadow:0 1px 0 rgba(0,0,0,0.6)}
#controls{position:absolute;right:18px;bottom:18px;color:var(--muted);font-size:13px}
.touch-controls{display:none;position:fixed;left:0;right:0;bottom:12px;pointer-events:none;justify-content:center;gap:12px}
.touch-controls .pad{pointer-events:auto;background:rgba(255,255,255,0.04);padding:10px;border-radius:12px;display:flex;gap:8px}
.touch-controls button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:10px;border-radius:8px;font-weight:700}
@media (max-width:720px){ .touch-controls{display:flex} header{flex-direction:column;gap:8px} }
.muted{color:var(--muted);font-weight:600}
.big{font-size:18px;color:#fff}
#bossbar{position:absolute;left:50%;transform:translateX(-50%);top:8px;width:60%;height:14px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;display:none}
#bossbar > .fill{height:100%;background:linear-gradient(90deg,#ff6b6b,#ffb86b);width:100%}
#overlay{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(2,6,23,0.6);display:flex;align-items:center;justify-content:center;z-index:40;display:none}
#overlay .card{background:#071827;padding:20px;border-radius:12px;color:#eaf7f0;max-width:720px;text-align:left}
.controls-row{display:flex;gap:8px;align-items:center}
.slider{width:120px}
.small{font-size:12px;color:var(--muted)}
/* HUD mini panels */
.hud-mini{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:8px;font-size:13px;color:var(--muted)}
/* Tooltip */
.tooltip{position:fixed;pointer-events:none;background:rgba(0,0,0,0.7);color:#fff;padding:6px 8px;border-radius:6px;font-size:12px;display:none;z-index:60}
</style>
</head>
<body>
<div id="game-wrap">
  <header>
    <div style="display:flex;gap:12px;align-items:center">
      <div class="panel">
        <h1>Astro Defender — Ultimate</h1>
        <div style="width:1px;height:28px;background:rgba(255,255,255,0.03);margin:0 10px"></div>
        <div class="info">
          <div>Mode: <span id="mode" class="muted">Campaign</span></div>
          <div>Level: <span id="level" class="muted">1</span></div>
        </div>
      </div>
    </div>

    <div style="display:flex;gap:8px;align-items:center">
      <div class="panel" style="padding:6px 10px">
        <div class="info">
          <div>Score: <span id="score" class="big">0</span></div>
          <div style="width:1px;height:28px;background:rgba(255,255,255,0.03);margin:0 10px"></div>
          <div>Lives: <span id="lives" class="big">3</span></div>
        </div>
      </div>
      <div class="panel controls-row">
        <button id="btnRestart" class="btn primary">Restart</button>
        <button id="btnPause" class="btn">Pause</button>
        <button id="btnHelp" class="btn">Help</button>
      </div>
      <div class="panel controls-row">
        <button id="btnMusic" class="btn">Start Music</button>
        <button id="btnMute" class="btn">Mute</button>
        <label class="muted" style="font-size:13px">Music</label>
        <input id="vol" class="slider" type="range" min="0" max="1" step="0.01" value="0.18" />
      </div>
    </div>
  </header>

  <main style="position:relative;width:100%;max-width:1200px">
    <canvas id="game" width="1100" height="700" aria-label="Astro Defender game canvas"></canvas>
    <div id="hud" aria-hidden="true">WASD / Arrows • Space to shoot • P pause</div>
    <div id="controls" aria-hidden="true">Highscore: <span id="highscore" class="muted">0</span></div>
    <div id="bossbar"><div class="fill"></div></div>
  </main>

  <div class="touch-controls" aria-hidden="true">
    <div class="pad">
      <button id="leftBtn">◀</button>
      <button id="upBtn">▲</button>
      <button id="downBtn">▼</button>
      <button id="rightBtn">▶</button>
    </div>
    <div class="pad">
      <button id="shootBtn" class="primary">FIRE</button>
    </div>
  </div>

  <footer>
    <div class="muted">Single-file game • Difficulty curve • Bosses • Final boss • Embedded synth music</div>
  </footer>
</div>

<div id="overlay" role="dialog" aria-hidden="true">
  <div class="card">
    <h2>Astro Defender — Hjälp</h2>
    <p>Rörelse: WASD eller piltangenter. Skjut: Space. Pausa: P. Samla powerups för extra liv eller power. Bossar kommer var 3:e nivå och slutbossen efter nivå 9. Klicka Start Music för att aktivera bakgrundsljud (webbläsare kräver användarinteraktion).</p>
    <p style="margin-top:12px"><button id="closeHelp" class="btn primary">Stäng</button></p>
  </div>
</div>

<div id="tooltip" class="tooltip" aria-hidden="true"></div>

<script>
/* ============================================================
   Astro Defender — Ultimate (single-file)
   - All game logic in this script block
   - Features:
     * Player ship, enemies, bullets, particles
     * Levels with difficulty curve (linear/exponential/stepped)
     * Bosses every 3 levels and a multi-wave final boss
     * Powerups: life, power, score
     * WebAudio synth for background music + SFX
     * Mobile touch controls
     * Local highscore (localStorage)
   - Paste this entire file into index.html and open in browser
   ============================================================ */

/* -------------------------
   Utilities
   ------------------------- */
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const rand = (a,b) => Math.random()*(b-a)+a;
const now = () => performance.now();

/* -------------------------
   Canvas setup
   ------------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });
let W = canvas.width, H = canvas.height;

/* -------------------------
   Game state
   ------------------------- */
let state = {
  running: true,
  paused: false,
  lastTime: now(),
  dt: 0,
  score: 0,
  level: 1,
  lives: 3,
  highscore: 0,
  spawnTimer: 0,
  spawnInterval: 1200,
  enemies: [],
  bullets: [],
  enemyBullets: [],
  particles: [],
  powerups: [],
  player: null,
  keys: {},
  touch: {left:false,right:false,up:false,down:false,shoot:false},
  difficulty: 1,
  boss: null,
  finalBoss: null,
  levelCleared: false,
  difficultyMode: 'exponential' // 'linear' | 'exponential' | 'stepped'
};

/* -------------------------
   Highscore
   ------------------------- */
const HS_KEY = 'astro_defender_ultimate_hs_v1';
function loadHighscore(){
  try{ const v = localStorage.getItem(HS_KEY); state.highscore = v?parseInt(v,10):0; }
  catch(e){ state.highscore = 0; }
  document.getElementById('highscore').textContent = state.highscore;
}
function saveHighscore(){
  try{ localStorage.setItem(HS_KEY, String(state.highscore)); }
  catch(e){}
}

/* -------------------------
   Difficulty curve
   ------------------------- */
function computeDifficulty(level){
  const mode = state.difficultyMode;
  if(mode === 'linear'){
    return 1 + (level - 1) * 0.18;
  } else if(mode === 'stepped'){
    return 1 + Math.floor((level-1)/2) * 0.35;
  } else { // exponential default
    return Math.pow(1.12, level-1);
  }
}

/* -------------------------
   Player class
   ------------------------- */
class Player {
  constructor(){
    this.x = W/2; this.y = H - 100;
    this.r = 18; this.speed = 380; this.cool = 0; this.coolMax = 160;
    this.color = '#4ee1a1'; this.invuln = 0; this.health = 3;
    this.power = 0;
  }
  update(dt){
    const k = state.keys;
    let vx = 0, vy = 0;
    if(k.ArrowLeft || k.a || state.touch.left) vx = -1;
    if(k.ArrowRight || k.d || state.touch.right) vx = 1;
    if(k.ArrowUp || k.w || state.touch.up) vy = -1;
    if(k.ArrowDown || k.s || state.touch.down) vy = 1;
    const len = Math.hypot(vx,vy) || 1;
    this.x += (vx/len) * this.speed * dt;
    this.y += (vy/len) * this.speed * dt;
    this.x = clamp(this.x, this.r+8, W - this.r - 8);
    this.y = clamp(this.y, this.r+8, H - this.r - 120);

    this.cool -= dt*1000;
    if((k.Space || k[' '] || state.touch.shoot) && this.cool <= 0){
      this.shoot();
      this.cool = this.coolMax;
    }
    if(this.invuln > 0) this.invuln -= dt*1000;
  }
  shoot(){
    const shots = 1 + Math.floor(this.power/2);
    const spread = 0.18;
    for(let i=0;i<shots;i++){
      const a = (i - (shots-1)/2) * spread;
      const vx = Math.sin(a) * 420;
      const vy = -Math.cos(a) * 420;
      const b = new Bullet(this.x + Math.sin(a)*8, this.y - this.r - 6, vx, vy, '#e6f9ff', 'player');
      b.r = 5; b.damage = 1;
      state.bullets.push(b);
    }
    sfx('shoot');
  }
  draw(ctx){
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.fillStyle = this.invuln>0 ? 'rgba(78,225,161,0.6)' : this.color;
    ctx.beginPath();
    ctx.moveTo(0,-20);
    ctx.lineTo(14,14);
    ctx.lineTo(0,8);
    ctx.lineTo(-14,14);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = 'rgba(255,180,80,0.12)';
    ctx.beginPath();
    ctx.ellipse(0,16,12,6,0,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#2bffb0';
    for(let i=0;i<this.health;i++){
      ctx.fillRect(-22 + i*14, 22, 10, 4);
    }
    ctx.restore();
  }
}

/* -------------------------
   Bullet class
   ------------------------- */
class Bullet {
  constructor(x,y,vx,vy,color,owner='enemy'){
    this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.color=color;this.owner=owner;this.r=6;this.damage=1;
  }
  update(dt){ this.x += this.vx*dt; this.y += this.vy*dt; }
  draw(ctx){
    ctx.fillStyle = this.color;
    ctx.beginPath(); ctx.ellipse(this.x,this.y,this.r,this.r,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath(); ctx.ellipse(this.x-1,this.y-1,this.r*0.5,this.r*0.5,0,0,Math.PI*2); ctx.fill();
  }
}

/* -------------------------
   Enemy class
   ------------------------- */
class Enemy {
  constructor(x,y,type=0,level=1){
    this.x=x;this.y=y;this.type=type;this.r=18;
    this.hp= type===1? Math.ceil(3 * computeDifficulty(level)) : Math.ceil(1 * computeDifficulty(level));
    this.color = type===1? '#ffb86b' : '#ff6b6b';
    this.speed = type===1? 40 : 80;
    this.shootTimer = rand(900,2200);
    this.osc = rand(0,Math.PI*2);
  }
  update(dt){
    this.osc += dt*2;
    this.x += Math.sin(this.osc) * 20 * dt;
    this.y += this.speed*dt;
    this.shootTimer -= dt*1000;
    if(this.shootTimer <= 0){
      this.shootTimer = rand(900,2200);
      this.fire();
    }
  }
  fire(){
    const angle = Math.atan2(state.player.y - this.y, state.player.x - this.x);
    const speed = 160 + computeDifficulty(state.level)*20;
    const vx = Math.cos(angle)*speed;
    const vy = Math.sin(angle)*speed;
    const b = new Bullet(this.x, this.y+this.r+6, vx, vy, '#ffd6d6', 'enemy');
    b.r = 6; b.damage = 1;
    state.enemyBullets.push(b);
    sfx('enemyShoot');
  }
  draw(ctx){
    ctx.save(); ctx.translate(this.x,this.y);
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(0,-this.r);
    ctx.lineTo(this.r,0);
    ctx.lineTo(0,this.r);
    ctx.lineTo(-this.r,0);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.beginPath(); ctx.ellipse(-4,-4,6,4,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

/* -------------------------
   Boss classes
   ------------------------- */
class Boss {
  constructor(level){
    this.x = W/2; this.y = -160;
    this.r = 70;
    this.level = level;
    this.phase = 0;
    this.maxHP = Math.ceil((120 + (level-1)*60) * computeDifficulty(level));
    this.hp = this.maxHP;
    this.timer = 0;
    this.targetY = 140;
    this.color = '#ff6b6b';
    this.alive = true;
  }
  update(dt){
    if(this.y < this.targetY){ this.y += 80 * dt; return; }
    this.timer += dt*1000;
    if(this.hp < this.maxHP * 0.65 && this.phase < 1){ this.phase = 1; this.timer = 0; sfx('power'); }
    if(this.hp < this.maxHP * 0.35 && this.phase < 2){ this.phase = 2; this.timer = 0; sfx('power'); }
    if(this.phase === 0){
      this.x += Math.sin(this.timer/600) * 60 * dt;
      if(this.timer > 900) { this.shootSpread(6, 220); this.timer = 0; }
    } else if(this.phase === 1){
      this.x += Math.sin(this.timer/400) * 120 * dt;
      if(this.timer > 700) { this.shootSpiral(10, 0.12); this.timer = 0; }
    } else {
      this.x += Math.sin(this.timer/200) * 180 * dt;
      if(this.timer > 500) { this.shootBurst(16); this.timer = 0; }
    }
    this.x = clamp(this.x, this.r+20, W - this.r - 20);
  }
  draw(ctx){
    ctx.save(); ctx.translate(this.x,this.y);
    ctx.fillStyle = this.color;
    ctx.beginPath(); ctx.ellipse(0,0,this.r,this.r,0,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 3;
    for(let i=0;i<6;i++){ ctx.beginPath(); ctx.ellipse(0,0,this.r - i*8,this.r - i*8,0,0,Math.PI*2); ctx.stroke(); }
    ctx.restore();
  }
  takeDamage(d){
    this.hp -= d;
    spawnExplosion(this.x + rand(-20,20), this.y + rand(-20,20), '#ffb86b', 6);
    if(this.hp <= 0){ this.alive = false; spawnExplosion(this.x, this.y, '#ffb86b', 60); sfx('explode'); }
    else sfx('hit');
  }
  shootSpread(count, speed){
    for(let i=0;i<count;i++){
      const a = (i/(count-1) - 0.5) * Math.PI * 0.9;
      const vx = Math.sin(a) * speed;
      const vy = Math.cos(a) * speed;
      state.enemyBullets.push(new Bullet(this.x + Math.sin(a)*20, this.y + 30, vx, vy, '#ffd6d6', 'enemy'));
    }
  }
  shootSpiral(count, step){
    for(let i=0;i<count;i++){
      const a = (this.timer/1000) + i*step;
      const vx = Math.cos(a) * 180;
      const vy = Math.sin(a) * 180;
      state.enemyBullets.push(new Bullet(this.x + Math.cos(a)*30, this.y + Math.sin(a)*30, vx, vy, '#ffd6d6', 'enemy'));
    }
  }
  shootBurst(count){
    for(let i=0;i<count;i++){
      const a = rand(0,Math.PI*2);
      const vx = Math.cos(a) * 260;
      const vy = Math.sin(a) * 260;
      state.enemyBullets.push(new Bullet(this.x + Math.cos(a)*40, this.y + Math.sin(a)*40, vx, vy, '#ffd6d6', 'enemy'));
    }
  }
}

/* Final boss with multiple waves */
class FinalBoss {
  constructor(){
    this.x = W/2; this.y = -220;
    this.r = 110;
    this.phase = 0;
    this.wave = 0;
    this.maxHP = 1200;
    this.hp = this.maxHP;
    this.timer = 0;
    this.targetY = 180;
    this.alive = true;
    this.stage = 0; // stage within final boss (multiple waves)
    this.spawnCooldown = 0;
  }
  update(dt){
    if(this.y < this.targetY){ this.y += 60 * dt; return; }
    this.timer += dt*1000;
    if(this.stage === 0){
      if(this.timer > 700){ this.shootRotating(18, 0.06); this.timer = 0; this.wave++; }
      if(this.wave > 6) { this.stage = 1; this.wave = 0; this.timer = 0; sfx('power'); }
    } else if(this.stage === 1){
      this.spawnCooldown -= dt*1000;
      if(this.spawnCooldown <= 0){
        this.spawnCooldown = 1400;
        this.spawnMinions(4);
      }
      if(this.timer > 900){ this.shootBurst(24); this.timer = 0; this.wave++; }
      if(this.wave > 5){ this.stage = 2; this.wave = 0; this.timer = 0; sfx('power'); }
    } else {
      if(this.timer > 450){ this.shootSpiral(30, 0.08); this.timer = 0; this.wave++; }
    }
    this.x += Math.sin(this.timer/500) * 80 * dt;
    this.x = clamp(this.x, this.r+20, W - this.r - 20);
  }
  draw(ctx){
    ctx.save(); ctx.translate(this.x,this.y);
    ctx.fillStyle = '#ff9fb0';
    ctx.beginPath(); ctx.ellipse(0,0,this.r,this.r,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ff6b6b';
    ctx.beginPath(); ctx.ellipse(0,0,this.r*0.6,this.r*0.6,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  takeDamage(d){
    this.hp -= d;
    spawnExplosion(this.x + rand(-40,40), this.y + rand(-40,40), '#ffb86b', 8);
    if(this.hp <= 0){ this.alive = false; spawnExplosion(this.x, this.y, '#ffb86b', 120); sfx('explode'); }
    else sfx('hit');
  }
  shootRotating(count, step){
    for(let i=0;i<count;i++){
      const a = (this.timer/1000) + i*step;
      const vx = Math.cos(a) * 180;
      const vy = Math.sin(a) * 180;
      state.enemyBullets.push(new Bullet(this.x + Math.cos(a)*40, this.y + Math.sin(a)*40, vx, vy, '#ffd6d6', 'enemy'));
    }
  }
  shootSpiral(count, step){
    for(let i=0;i<count;i++){
      const a = (this.timer/1000) + i*step;
      const vx = Math.cos(a) * 220;
      const vy = Math.sin(a) * 220;
      state.enemyBullets.push(new Bullet(this.x + Math.cos(a)*50, this.y + Math.sin(a)*50, vx, vy, '#ffd6d6', 'enemy'));
    }
  }
  shootBurst(count){
    for(let i=0;i<count;i++){
      const a = rand(0,Math.PI*2);
      const vx = Math.cos(a) * 300;
      const vy = Math.sin(a) * 300;
      state.enemyBullets.push(new Bullet(this.x + Math.cos(a)*60, this.y + Math.sin(a)*60, vx, vy, '#ffd6d6', 'enemy'));
    }
  }
  spawnMinions(n){
    for(let i=0;i<n;i++){
      const x = this.x + rand(-this.r, this.r);
      const y = this.y + this.r + rand(20,60);
      state.enemies.push(new Enemy(x,y, Math.random()<0.5?1:0, state.level));
    }
  }
}

/* -------------------------
   Particle class
   ------------------------- */
class Particle {
  constructor(x,y,vx,vy,color,life=600){
    this.x=x;this.y=y;this.vx=vx;this.vy=vy;this.color=color;this.life=life;this.age=0;this.r=2;
  }
  update(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; this.age+=dt*1000; }
  draw(ctx){
    const t = 1 - (this.age/this.life);
    if(t<=0) return;
    ctx.fillStyle = hexAlpha(this.color, t);
    ctx.beginPath(); ctx.ellipse(this.x,this.y,this.r*t*2,this.r*t*2,0,0,Math.PI*2); ctx.fill();
  }
}

/* -------------------------
   Powerup class
   ------------------------- */
class Powerup {
  constructor(x,y,kind='score'){
    this.x=x;this.y=y;this.kind=kind;this.r=10;this.vy=60;
  }
  update(dt){ this.y += this.vy*dt; }
  draw(ctx){
    ctx.save(); ctx.translate(this.x,this.y);
    ctx.fillStyle = this.kind==='life' ? '#4ee1a1' : (this.kind==='power' ? '#7ad7ff' : '#ffd166');
    ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath(); ctx.arc(-3,-3,4,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

/* -------------------------
   Helpers
   ------------------------- */
function hexAlpha(hex, a){
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${a})`;
}

/* -------------------------
   Spawning
   ------------------------- */
function spawnEnemyWave(level){
  const base = 3 + Math.floor(level * 1.2);
  const count = Math.min(18, base + Math.floor(Math.random()*4));
  for(let i=0;i<count;i++){
    const x = rand(40, W-40);
    const y = rand(-500, -40) - i*30;
    const type = Math.random() < Math.min(0.28, level*0.04) ? 1 : 0;
    state.enemies.push(new Enemy(x,y,type, level));
  }
}

/* -------------------------
   Collision
   ------------------------- */
function circleCollide(a,b){
  const dx = a.x - b.x, dy = a.y - b.y;
  const r = (a.r||0) + (b.r||0);
  return dx*dx + dy*dy <= r*r;
}

/* -------------------------
   Audio (WebAudio synth + sfx)
   ------------------------- */
const audioCtx = (typeof AudioContext !== 'undefined') ? new AudioContext() : null;
let musicGain = null;
let musicOsc = null;
let musicPlaying = false;
let masterGain = null;

function initAudio(){
  if(!audioCtx) return;
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.9;
  masterGain.connect(audioCtx.destination);
  musicGain = audioCtx.createGain();
  musicGain.gain.value = parseFloat(document.getElementById('vol').value || 0.18);
  musicGain.connect(masterGain);
  // create a simple looped ambient synth using oscillator + noise
  musicOsc = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const lfo = audioCtx.createOscillator();
  const lfoGain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  const noise = audioCtx.createBufferSource();
  const bufferSize = audioCtx.sampleRate * 2;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1)*0.02;
  noise.buffer = buffer; noise.loop = true;
  musicOsc.type = 'sine'; musicOsc.frequency.value = 110;
  osc2.type = 'sine'; osc2.frequency.value = 220; osc2.detune.value = 6;
  lfo.type = 'sine'; lfo.frequency.value = 0.08; lfoGain.gain.value = 20;
  filter.type = 'lowpass'; filter.frequency.value = 800;
  lfo.connect(lfoGain);
  lfoGain.connect(musicOsc.frequency);
  lfoGain.connect(osc2.frequency);
  musicOsc.connect(filter);
  osc2.connect(filter);
  noise.connect(filter);
  filter.connect(musicGain);
  musicOsc.start();
  osc2.start();
  lfo.start();
  noise.start();
  musicPlaying = true;
}

function stopAudio(){
  if(!audioCtx || !musicPlaying) return;
  try{ musicOsc.stop(); }catch(e){}
  musicPlaying = false;
}

/* small sfx synth */
function sfx(type){
  if(!audioCtx) return;
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  if(type==='shoot'){ o.frequency.setValueAtTime(880,t); g.gain.setValueAtTime(0.06,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.12); }
  else if(type==='enemyShoot'){ o.frequency.setValueAtTime(420,t); g.gain.setValueAtTime(0.04,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.18); }
  else if(type==='explode'){ o.frequency.setValueAtTime(120,t); g.gain.setValueAtTime(0.12,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.4); o.type='square'; }
  else if(type==='power'){ o.frequency.setValueAtTime(1200,t); g.gain.setValueAtTime(0.06,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.18); }
  else if(type==='hit'){ o.frequency.setValueAtTime(520,t); g.gain.setValueAtTime(0.04,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.08); }
  o.connect(g); g.connect(masterGain || audioCtx.destination); o.start(t); o.stop(t+0.5);
}

/* -------------------------
   Game logic
   ------------------------- */
function resetGame(){
  state.score = 0; state.level = 1; state.lives = 3; state.enemies=[]; state.bullets=[]; state.enemyBullets=[]; state.particles=[]; state.powerups=[];
  state.spawnTimer = 0; state.spawnInterval = 1200; state.difficulty = 1;
  state.boss = null; state.finalBoss = null; state.levelCleared = false;
  state.player = new Player();
  document.getElementById('score').textContent = state.score;
  document.getElementById('lives').textContent = state.lives;
  document.getElementById('level').textContent = state.level;
  document.getElementById('bossbar').style.display = 'none';
  state.paused = false;
}

function nextLevel(){
  state.level++;
  state.difficulty = computeDifficulty(state.level);
  document.getElementById('level').textContent = state.level;
  if(state.level % 3 === 0 && state.level < 10){
    spawnBoss(state.level);
  } else if(state.level === 10){
    spawnFinalBoss();
  } else {
    spawnEnemyWave(state.level);
  }
  sfx('power');
}

function spawnBoss(level){
  state.boss = new Boss(level);
  document.getElementById('bossbar').style.display = 'block';
  updateBossBar();
}

function spawnFinalBoss(){
  state.finalBoss = new FinalBoss();
  document.getElementById('bossbar').style.display = 'block';
  updateBossBar();
}

/* -------------------------
   Update loop
   ------------------------- */
function update(dt){
  if(!state.running || state.paused) return;
  state.player.update(dt);
  for(const b of state.bullets) b.update(dt);
  for(const b of state.enemyBullets) b.update(dt);
  for(const e of state.enemies) e.update(dt);
  if(state.boss){
    state.boss.update(dt);
    if(!state.boss.alive){
      state.score += 600 * Math.round(state.difficulty);
      state.boss = null;
      document.getElementById('bossbar').style.display = 'none';
      for(let i=0;i<3;i++) state.powerups.push(new Powerup(W/2 + rand(-80,80), 160 + i*20, i===0?'life':(i===1?'power':'score')));
      state.levelCleared = true;
    } else updateBossBar();
  }
  if(state.finalBoss){
    state.finalBoss.update(dt);
    if(!state.finalBoss.alive){
      state.score += 5000;
      state.finalBoss = null;
      document.getElementById('bossbar').style.display = 'none';
      setTimeout(()=> { alert('Grattis! Du besegrade slutbossen! Score: ' + state.score); resetGame(); }, 300);
    } else updateBossBar();
  }
  for(const p of state.particles) p.update(dt);
  for(const pu of state.powerups) pu.update(dt);

  for(let i=state.bullets.length-1;i>=0;i--){
    const b = state.bullets[i];
    if(b.owner !== 'player') continue;
    let removed = false;
    if(state.finalBoss && circleCollide(b, state.finalBoss)){
      state.bullets.splice(i,1);
      state.finalBoss.takeDamage(b.damage);
      removed = true;
      continue;
    }
    if(state.boss && circleCollide(b, state.boss)){
      state.bullets.splice(i,1);
      state.boss.takeDamage(b.damage);
      removed = true;
      continue;
    }
    for(let j=state.enemies.length-1;j>=0;j--){
      const e = state.enemies[j];
      if(circleCollide(b,e)){
        e.hp -= b.damage;
        spawnExplosion(b.x,b.y,'#ffd6d6');
        state.bullets.splice(i,1);
        removed = true;
        if(e.hp <= 0){
          spawnExplosion(e.x,e.y,'#ffb86b', 18);
          state.enemies.splice(j,1);
          state.score += (e.type===1? 150 : 50) * Math.round(state.difficulty);
          if(Math.random() < 0.12) state.powerups.push(new Powerup(e.x,e.y,'life'));
          else if(Math.random() < 0.18) state.powerups.push(new Powerup(e.x,e.y,'power'));
          else if(Math.random() < 0.12) state.powerups.push(new Powerup(e.x,e.y,'score'));
          sfx('explode');
        }
        break;
      }
    }
    if(removed) continue;
    if(b.y < -40 || b.y > H+40 || b.x < -80 || b.x > W+80) state.bullets.splice(i,1);
  }

  if(state.player.invuln <= 0){
    for(let i=state.enemyBullets.length-1;i>=0;i--){
      const b = state.enemyBullets[i];
      if(circleCollide(b, state.player)){
        state.enemyBullets.splice(i,1);
        hitPlayer();
        break;
      }
    }
  }

  for(let i=state.enemies.length-1;i>=0;i--){
    const e = state.enemies[i];
    if(circleCollide(e, state.player) && state.player.invuln <= 0){
      state.enemies.splice(i,1);
      hitPlayer();
      spawnExplosion(e.x,e.y,'#ff6b6b', 20);
      break;
    }
  }

  for(let i=state.powerups.length-1;i>=0;i--){
    const pu = state.powerups[i];
    if(circleCollide(pu, state.player)){
      if(pu.kind === 'life'){ state.lives = Math.min(6, state.lives + 1); document.getElementById('lives').textContent = state.lives; }
      else if(pu.kind === 'power'){ state.player.power = Math.min(8, state.player.power + 1); }
      else { state.score += 200; document.getElementById('score').textContent = state.score; }
      state.powerups.splice(i,1);
      sfx('power');
    } else if(pu.y > H + 40) state.powerups.splice(i,1);
  }

  for(let i=state.enemies.length-1;i>=0;i--){
    if(state.enemies[i].y > H + 120) state.enemies.splice(i,1);
  }
  for(let i=state.enemyBullets.length-1;i>=0;i--){
    const b = state.enemyBullets[i];
    if(b.y > H + 200 || b.x < -200 || b.x > W + 200) state.enemyBullets.splice(i,1);
  }
  for(let i=state.particles.length-1;i>=0;i--){
    if(state.particles[i].age > state.particles[i].life) state.particles.splice(i,1);
  }

  if(!state.boss && !state.finalBoss){
    state.spawnTimer -= dt*1000;
    if(state.spawnTimer <= 0){
      state.spawnTimer = state.spawnInterval / Math.sqrt(state.difficulty);
      spawnEnemyWave(state.level);
    }
  }

  if(!state.boss && !state.finalBoss && state.enemies.length === 0 && state.enemyBullets.length === 0 && state.spawnTimer > 800){
    if(!state.levelCleared){
      state.levelCleared = true;
      setTimeout(()=> {
        nextLevel();
        state.levelCleared = false;
      }, 900);
    }
  }

  document.getElementById('score').textContent = state.score;
  if(state.score > state.highscore){ state.highscore = state.score; document.getElementById('highscore').textContent = state.highscore; saveHighscore(); }
}

/* -------------------------
   Player hit
   ------------------------- */
function hitPlayer(){
  state.lives -= 1;
  document.getElementById('lives').textContent = state.lives;
  state.player.invuln = 1400;
  state.player.health = Math.max(0, state.player.health - 1);
  spawnExplosion(state.player.x, state.player.y, '#ff6b6b', 28);
  sfx('explode');
  if(state.lives <= 0){
    gameOver();
  }
}

/* -------------------------
   Explosion
   ------------------------- */
function spawnExplosion(x,y,color,amount=10){
  for(let i=0;i<amount;i++){
    const a = rand(0,Math.PI*2);
    const s = rand(40,260);
    const vx = Math.cos(a)*s;
    const vy = Math.sin(a)*s;
    state.particles.push(new Particle(x,y,vx,vy,color, rand(400,900)));
  }
}

/* -------------------------
   Game over
   ------------------------- */
function gameOver(){
  state.paused = true;
  state.running = false;
  setTimeout(()=> {
    const msg = `Game Over\nScore: ${state.score}\nHighscore: ${state.highscore}`;
    alert(msg);
    resetGame();
  }, 80);
}

/* -------------------------
   Draw
   ------------------------- */
function draw(){
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#07101a'); g.addColorStop(1,'#04101a');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  drawStars();

  for(const pu of state.powerups) pu.draw(ctx);
  for(const e of state.enemies) e.draw(ctx);
  for(const b of state.bullets) b.draw(ctx);
  for(const b of state.enemyBullets) b.draw(ctx);
  if(state.boss) state.boss.draw(ctx);
  if(state.finalBoss) state.finalBoss.draw(ctx);
  state.player.draw(ctx);
  for(const p of state.particles) p.draw(ctx);

  if(state.paused){
    ctx.fillStyle = 'rgba(2,6,23,0.6)';
    ctx.fillRect(W/2 - 220, H/2 - 90, 440, 180);
    ctx.fillStyle = '#fff';
    ctx.font = '22px Inter, Arial';
    ctx.textAlign = 'center';
    ctx.fillText(state.running ? 'Paused' : 'Game Over', W/2, H/2 - 10);
    ctx.font = '14px Inter, Arial';
    ctx.fillStyle = '#bcd';
    ctx.fillText('Tryck Restart för att spela igen', W/2, H/2 + 20);
  }
}

/* -------------------------
   Starfield
   ------------------------- */
const stars = [];
for(let i=0;i<220;i++){
  stars.push({x:rand(0,W), y:rand(0,H), r:rand(0.3,1.6), s:rand(10,160)});
}
function drawStars(){
  for(const s of stars){
    s.y += s.s * 0.016 * Math.sqrt(state.difficulty);
    if(s.y > H) s.y = -2;
    ctx.fillStyle = `rgba(255,255,255,${0.06 + s.r*0.06})`;
    ctx.beginPath(); ctx.ellipse(s.x, s.y, s.r, s.r, 0, 0, Math.PI*2); ctx.fill();
  }
}

/* -------------------------
   Input
   ------------------------- */
window.addEventListener('keydown', e => {
  state.keys[e.key] = true;
  if(e.key === 'p' || e.key === 'P') togglePause();
  if(e.key === 'r' || e.key === 'R') resetGame();
  if(e.key === 'h' || e.key === 'H') showHelp();
  if(e.key === ' '){ e.preventDefault(); }
});
window.addEventListener('keyup', e => { state.keys[e.key] = false; });

/* Touch controls */
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const upBtn = document.getElementById('upBtn');
const downBtn = document.getElementById('downBtn');
const shootBtn = document.getElementById('shootBtn');
function bindTouch(btn, keyName){
  btn.addEventListener('touchstart', e => { e.preventDefault(); state.touch[keyName] = true; });
  btn.addEventListener('touchend', e => { e.preventDefault(); state.touch[keyName] = false; });
  btn.addEventListener('mousedown', e => { e.preventDefault(); state.touch[keyName] = true; });
  btn.addEventListener('mouseup', e => { e.preventDefault(); state.touch[keyName] = false; });
}
bindTouch(leftBtn,'left'); bindTouch(rightBtn,'right'); bindTouch(upBtn,'up'); bindTouch(downBtn,'down'); bindTouch(shootBtn,'shoot');

/* -------------------------
   Resize handling
   ------------------------- */
function resizeCanvas(){
  const maxW = Math.min(window.innerWidth - 36, 1200);
  const scale = maxW / W;
  canvas.style.width = (W * scale) + 'px';
  canvas.style.height = (H * scale) + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* -------------------------
   Buttons
   ------------------------- */
document.getElementById('btnRestart').addEventListener('click', () => {
  resetGame();
  state.running = true;
  state.paused = false;
});
document.getElementById('btnPause').addEventListener('click', () => togglePause());
document.getElementById('btnHelp').addEventListener('click', () => showHelp());
document.getElementById('closeHelp').addEventListener('click', () => hideHelp());

function togglePause(){
  state.paused = !state.paused;
  document.getElementById('btnPause').textContent = state.paused ? 'Resume' : 'Pause';
}

/* Music controls */
document.getElementById('btnMusic').addEventListener('click', () => {
  if(!audioCtx) return alert('Ljud stöds inte i denna webbläsare.');
  if(!musicPlaying){
    if(audioCtx.state === 'suspended') audioCtx.resume();
    initAudio();
    document.getElementById('btnMusic').textContent = 'Music On';
  } else {
    stopAudio();
    document.getElementById('btnMusic').textContent = 'Start Music';
  }
});
document.getElementById('btnMute').addEventListener('click', () => {
  if(!audioCtx) return;
  if(masterGain){
    masterGain.gain.value = masterGain.gain.value > 0 ? 0 : 0.9;
    document.getElementById('btnMute').textContent = masterGain.gain.value === 0 ? 'Unmute' : 'Mute';
  }
});
document.getElementById('vol').addEventListener('input', (e) => {
  if(musicGain) musicGain.gain.value = parseFloat(e.target.value);
});

/* -------------------------
   Boss bar
   ------------------------- */
function updateBossBar(){
  const el = document.querySelector('#bossbar .fill');
  if(state.finalBoss){
    const pct = clamp(state.finalBoss.hp / state.finalBoss.maxHP, 0, 1);
    el.style.width = (pct*100) + '%';
    document.getElementById('bossbar').style.display = 'block';
  } else if(state.boss){
    const pct = clamp(state.boss.hp / state.boss.maxHP, 0, 1);
    el.style.width = (pct*100) + '%';
    document.getElementById('bossbar').style.display = 'block';
  } else {
    document.getElementById('bossbar').style.display = 'none';
  }
}

/* -------------------------
   Main loop
   ------------------------- */
function loop(){
  const t = now();
  let dt = (t - state.lastTime) / 1000;
  dt = Math.min(dt, 0.033);
  state.lastTime = t;
  state.dt = dt;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

/* -------------------------
   Init
   ------------------------- */
function init(){
  loadHighscore();
  resetGame();
  spawnEnemyWave(1);
  state.player = new Player();
  state.running = true;
  state.paused = false;
  state.lastTime = now();
  loop();
}
init();

/* -------------------------
   Debug helpers
   ------------------------- */
window.__astro = {
  addEnemy: (n=1) => { for(let i=0;i<n;i++) state.enemies.push(new Enemy(rand(40,W-40), rand(-200,-40), Math.random()<0.2?1:0, state.level)); },
  addScore: (s=100) => { state.score += s; document.getElementById('score').textContent = state.score; },
  spawnFinal: () => { spawnFinalBoss(); }
};

/* -------------------------
   UI helpers
   ------------------------- */
function showHelp(){ document.getElementById('overlay').style.display = 'flex'; document.getElementById('overlay').setAttribute('aria-hidden','false'); }
function hideHelp(){ document.getElementById('overlay').style.display = 'none'; document.getElementById('overlay').setAttribute('aria-hidden','true'); }

/* -------------------------
   Visibility pause
   ------------------------- */
document.addEventListener('visibilitychange', () => {
  if(document.hidden && !state.paused){ state.paused = true; document.getElementById('btnPause').textContent = 'Resume'; }
});

/* End of script */
</script>
</body>
</html>
